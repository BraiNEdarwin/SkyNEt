[1mdiff --git a/experiments/Web/search_logic_gates.py b/experiments/Web/search_logic_gates.py[m
[1mindex 61e7174..dc220dc 100644[m
[1m--- a/experiments/Web/search_logic_gates.py[m
[1m+++ b/experiments/Web/search_logic_gates.py[m
[36m@@ -24,28 +24,28 @@[m [mfrom SkyNEt.modules.Nets.webNNet import webNNet[m
 # ------------------------ configure ------------------------[m
 # load device simulation[m
 main_dir = r'/home/lennart/Dropbox/afstuderen/search_scripts/'[m
[31m-#data_dir = 'lr2e-4_eps400_mb512_20180807CP.pt'[m
[31m-data_dir = 'NN_skip3_MSE.pt'[m
[32m+[m[32mdata_dir = 'lr2e-4_eps400_mb512_20180807CP.pt'[m
[32m+[m[32m#data_dir = 'NN_skip3_MSE.pt'[m
 net1 = staNNet(main_dir+data_dir)[m
 [m
 # single device web[m
 web = webNNet()[m
[31m-web.add_vertex(net1, 'A', output=True, input_gates=[2,3])[m
[32m+[m[32mweb.add_vertex(net1, 'A', output=True, input_gates=[0,1])[m
 [m
 # input voltages of boolean inputs (on/upper, off/lower)[m
[31m-input_lower = -0.7[m
[31m-input_upper = 0.1[m
[32m+[m[32minput_lower = -0.9[m
[32m+[m[32minput_upper = 0.0[m
 [m
 # hardcoded target values of logic gates with off->lower and on->upper[m
[31m-upper = 10.0[m
[32m+[m[32mupper = 1.0[m
 lower = 0.0[m
 # if set to false, use output of known cv configurations as targets[m
 [m
 N = 100 # number of data points of one of four input cases, total 4*N[m
 [m
 batch_size = 100[m
[31m-max_epochs = 300[m
[31m-lr = 0.05[m
[32m+[m[32mmax_epochs = 500[m
[32m+[m[32mlr = 0.01[m
 beta = 10[m
 cv_reset = 'rand'[m
 [m
[36m@@ -133,7 +133,7 @@[m [melif training_type=='cor':[m
     def loss_fn(x, y):[m
         return cor_loss_fn(x[:,0], y[:,0])[m
 elif training_type=='cormse':[m
[31m-    alpha = 0.8 # fraction of cor and mse => 0:cor, 1: mse[m
[32m+[m[32m    alpha = 0.1 # fraction of cor and mse => 0:cor, 1: mse[m
     def loss_fn(x_in, y_in):[m
         x = x_in[:,0][m
         y = y_in[:,0][m
[36m@@ -166,7 +166,7 @@[m [mfor (i,gate) in enumerate(gates):[m
                      stop_fn = stop_fn,[m
                      lr = lr,[m
                      nr_sessions=5,[m
[31m-                     verbose=False)[m
[32m+[m[32m                     verbose=True)[m
     losslist.append(loss_l)[m
     trained_cv.append(best_cv)[m
 [m
[36m@@ -198,7 +198,7 @@[m [mdef print_gates():[m
         [m
         # print output network and targets[m
         plt.subplot(2, 3 , 1 + i//2 + i%2*3)[m
[31m-        plt.plot(target_data[i])[m
[32m+[m[32m        plt.plot(target_data[i].numpy())[m
         legend_list = ['target'][m
         if False: #training_type == 'bin':[m
             plt.plot(torch.sigmoid(output_data))[m
[36m@@ -206,16 +206,13 @@[m [mdef print_gates():[m
             plt.plot(torch.round(torch.sigmoid(output_data)))[m
             legend_list.append('classification')[m
         else:[m
[31m-            plt.plot(output_data)[m
[32m+[m[32m            plt.plot(output_data.numpy())[m
             legend_list.append('network '+str(round(loss, 3)))[m
         [m
         plt.legend(legend_list)[m
         plt.title("%s, cv:%s" % (gate, np.round(trained_cv[0]['A'].numpy(), 3)))[m
     # adjust margins[m
     plt.subplots_adjust(left=0.1, right=0.9, top=0.9, bottom=0.1)[m
[31m-    # fullscreen plot (only available with matplotlib auto)[m
[31m-    figManager = plt.get_current_fig_manager()[m
[31m-    figManager.window.showMaximized()[m
     plt.show()[m
 [m
 print_gates()[m
\ No newline at end of file[m
[1mdiff --git a/experiments/Web/search_logic_gates_GA.py b/experiments/Web/search_logic_gates_GA.py[m
[1mindex 09ca21e..d97f443 100644[m
[1m--- a/experiments/Web/search_logic_gates_GA.py[m
[1m+++ b/experiments/Web/search_logic_gates_GA.py[m
[36m@@ -66,30 +66,14 @@[m [minput_data[3*N:,    1] = 0.9[m
 [m
 gates = ['AND','NAND','OR','NOR','XOR','XNOR'][m
 [m
[31m-list_cv = torch.FloatTensor([m
[31m-      [[387,-387,650,55,-892],[477,-234,-332,-358,827],[m
[31m-       [9,183,714,-313,-416],[514,665,-64,855,846],[m
[31m-       [-771,342,900,-655,-48],[480,149,-900,-2,-450]])[m
[31m-list_cv += 900[m
[31m-list_cv /=1800[m
[31m-cv_data = torch.ones(6,4*N)[m
[31m-for (i, cv) in enumerate(list_cv):[m
[31m-    # set parameters of network to cv[m
[31m-    web.reset_parameters(cv)[m
[31m-    # evaluate network[m
[31m-    cv_data[i] = web.forward(input_data).data[:,0][m
[31m-[m
[31m-if target_hardcoded:[m
[31m-    target_data = upper*torch.ones(6, 4*N)[m
[31m-    target_data[0, :3*N] = lower[m
[31m-    target_data[1, 3*N:] = lower[m
[31m-    target_data[2, :N] = lower[m
[31m-    target_data[3, N:] = lower[m
[31m-    target_data[4, :N] = lower[m
[31m-    target_data[4, 3*N:] = lower[m
[31m-    target_data[5, N:3*N] = lower[m
[31m-else:[m
[31m-    target_data = torch.tensor(cv_data)[m
[32m+[m[32mtarget_data = upper*torch.ones(6, 4*N)[m
[32m+[m[32mtarget_data[0, :3*N] = lower[m
[32m+[m[32mtarget_data[1, 3*N:] = lower[m
[32m+[m[32mtarget_data[2, :N] = lower[m
[32m+[m[32mtarget_data[3, N:] = lower[m
[32m+[m[32mtarget_data[4, :N] = lower[m
[32m+[m[32mtarget_data[4, 3*N:] = lower[m
[32m+[m[32mtarget_data[5, N:3*N] = lower[m
 [m
 def cor_loss_fn(x, y):[m
     corr = torch.mean((x-torch.mean(x))*(y-torch.mean(y)))[m
[36m@@ -110,7 +94,7 @@[m [melif training_type=='cor':[m
     loss_fn = cor_loss_fn[m
 elif training_type=='cormse':[m
     def loss_fn(x, y):[m
[31m-        alpha = 0.6[m
[32m+[m[32m        alpha = 0.1[m
         mse = mse_loss_fn(x, y)[m
         cor = cor_loss_fn(x, y)[m
         return alpha*cor+(1-alpha)*mse[m
[36m@@ -157,19 +141,15 @@[m [mdef print_gates():[m
         print(gate)[m
         # print output network and targets[m
         plt.subplot(2, 3 , 1 + i//2 + i%2*3)[m
[31m-        legend_list = ['target', 'network', 'cv_output'][m
[32m+[m[32m        legend_list = ['target', 'network'][m
         plt.plot(target_data[i].numpy())[m
         web.reset_parameters(store_cvs[i])[m
         store_output[i] = web.forward(input_data).data[:,0][m
         plt.plot(store_output[i])[m
[31m-        plt.plot(cv_data[i].data)[m
         plt.legend(legend_list)[m
         plt.title("%s, cv:%s" % (gate, np.round(store_cvs[i], 3)))[m
     # adjust margins [m
     plt.subplots_adjust(left=0.1, right=0.9, top=0.9, bottom=0.1)[m
[31m-    # fullscreen plot   [m
[31m-    figManager = plt.get_current_fig_manager()[m
[31m-    figManager.window.showMaximized()[m
     plt.show()[m
 [m
 print_gates()[m
